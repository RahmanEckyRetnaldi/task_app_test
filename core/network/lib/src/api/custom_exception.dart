
import 'package:common_dependency/common_dependency.dart';
import 'package:dio/dio.dart';
import 'package:flutter/foundation.dart';

import 'failure.dart';

/// An enum that holds names for our custom exceptions.
enum CustomExceptionType {
  /// The exception for an expired bearer token.
  TokenExpiredException,
  Unauthorized,

  /// The exception for a prematurely cancelled request.
  CancelException,

  /// The exception for a failed connection attempt.
  ConnectTimeoutException,

  /// The exception for failing to send a request.
  SendTimeoutException,

  /// The exception for failing to receive a response.
  ReceiveTimeoutException,

  /// The exception for no internet connectivity.
  SocketException,

  /// A better name for the socket exception.
  FetchDataException,

  /// The exception for an incorrect parameter in a request/response.
  FormatException,

  /// The exception for an unknown type of failure.
  UnrecognizedException,

  /// The exception for an unknown exception from the api.
  ApiException,

  /// The exception for any parsing failure encountered during
  /// serialization/deserialization of a request.
  SerializationException,
}

/// Error class that will be thrown by DioService. the handler can also be
/// extended by setting customHandler in DioService
class DioServiceError extends Equatable implements Exception {
  /// error name
  final String name;

  /// error message
  final String message;

  /// error code, if available
  final String? code;

  /// status code if it's error response from server
  final int? statusCode;

  /// type of failure, primarily will be generated by fromDioException
  /// by transforming thrown error into failure
  final Failure failure;

  /// reason why the exception is thrown
  final CustomExceptionType exceptionType;

  /// data that's sent by the thrown error, usually for backend
  /// JSON body response when they send error response
  final dynamic data;

  DioServiceError({
    this.code,
    int? statusCode,
    required this.message,
    Failure? failureType,
    this.exceptionType = CustomExceptionType.ApiException,
    this.data,
  })  : statusCode = statusCode ?? 500,
        name = exceptionType.name,
        failure = failureType ?? UnRecognizedFailure(data);

  factory DioServiceError.fromDioException(dynamic error,
      {DioServiceError? Function(DioException)? customHandler}) {
    try {
      if (error is DioException) {
        final customError = customHandler?.call(error);
        if (customError != null) return customError;
        switch (error.type) {
          case DioExceptionType.cancel:
            return DioServiceError(
              exceptionType: CustomExceptionType.CancelException,
              statusCode: error.response?.statusCode,
              message: 'Request cancelled prematurely',
            );
          case DioExceptionType.connectionTimeout:
            return DioServiceError(
              exceptionType: CustomExceptionType.ConnectTimeoutException,
              statusCode: error.response?.statusCode,
              message: 'Connection not established',
              failureType: const NetworkFailure(),
            );
          case DioExceptionType.connectionError:
            return DioServiceError(
              exceptionType: CustomExceptionType.SocketException,
              statusCode: error.response?.statusCode,
              message: 'No internet connectivity',
              failureType: const NetworkFailure(),
            );
          case DioExceptionType.sendTimeout:
            return DioServiceError(
              exceptionType: CustomExceptionType.SendTimeoutException,
              statusCode: error.response?.statusCode,
              message: 'Failed to send',
              failureType: const NetworkFailure(),
            );
          case DioExceptionType.receiveTimeout:
            return DioServiceError(
              exceptionType: CustomExceptionType.ReceiveTimeoutException,
              statusCode: error.response?.statusCode,
              message: 'Failed to receive',
              failureType: const NetworkFailure(),
            );
          case DioExceptionType.badResponse:
            if (error.response?.statusCode == 401) {
              return DioServiceError(
                exceptionType: CustomExceptionType.Unauthorized,
                statusCode: error.response?.statusCode,
                message: 'Unauthorized user',
                data: error.response?.data,
                failureType: const UnAuthorizedFailure(),
              );
            } else {
              return DioServiceError(
                exceptionType: CustomExceptionType.Unauthorized,
                statusCode: error.response?.statusCode,
                message: 'Bad Response',
                data: error.response?.data,
                failureType: BadResponseFailure(
                    error.response?.data, error.response?.statusCode),
              );
            }
          default:
            if (error.message
                    ?.contains(CustomExceptionType.SocketException.name) ==
                true) {
              return DioServiceError(
                exceptionType: CustomExceptionType.FetchDataException,
                statusCode: error.response?.statusCode,
                message: 'No internet connectivity',
                failureType: const NetworkFailure(),
              );
            }
            if (error.response?.statusCode == null) {
              return DioServiceError(
                exceptionType: CustomExceptionType.UnrecognizedException,
                statusCode: error.response?.statusCode,
                message: error.response?.statusMessage ?? 'Unknown',
                failureType: const UnRecognizedFailure(),
              );
            }
            final name = error.response?.data['meta']['code'] as int;
            final message = error.response?.data['meta']['message'] as String;
            if (message == CustomExceptionType.TokenExpiredException.name) {
              return DioServiceError(
                exceptionType: CustomExceptionType.TokenExpiredException,
                code: name.toString(),
                statusCode: error.response?.statusCode,
                message: message,
                failureType: const UnAuthorizedFailure(),
              );
            }
            if (message == 'Unauthorized.') {
              return DioServiceError(
                exceptionType: CustomExceptionType.Unauthorized,
                statusCode: error.response?.statusCode,
                message: 'Unauthorized user',
                failureType: const UnAuthorizedFailure(),
              );
            }
            return DioServiceError(
              message: message,
              code: name.toString(),
              statusCode: error.response?.statusCode,
            );
        }
      } else {
        return DioServiceError(
          exceptionType: CustomExceptionType.UnrecognizedException,
          data: error,
          message: 'Error unrecognized',
        );
      }
    } on FormatException catch (e) {
      return DioServiceError(
        exceptionType: CustomExceptionType.FormatException,
        message: e.message,
        failureType: const FormatFailure(),
      );
    } catch (e) {
      return DioServiceError(
        exceptionType: CustomExceptionType.UnrecognizedException,
        data: e,
        message: 'Error unrecognized',
      );
    }
  }

  factory DioServiceError.fromParsingException(error) {
    debugPrint('$error');
    return DioServiceError(
      exceptionType: CustomExceptionType.SerializationException,
      message: 'Failed to parse network response to model or vice versa',
    );
  }

  DioServiceError transform(
          DioServiceError? Function(DioServiceError error)? handler) =>
      handler?.call(this) ?? this;

  @override
  List<Object> get props => [exceptionType, message];

  @override
  bool get stringify => true;
}
